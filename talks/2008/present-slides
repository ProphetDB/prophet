#!/usr/bin/env perl

use warnings;
use strict;
use Term::ANSIScreen qw/:color :cursor :screen :keyboard/;
use Term::ReadKey;
use Text::Autoformat;
our @SLIDES;

load_slides();
my $counter = 0;
my $slides_played = {};
	my $title;

open(my $next_slide, ">/tmp/next_slide");
select($next_slide);
$| = 1;
select(STDOUT);

my $cmd = q{ osascript -e ' tell application "Terminal"' -e ' do script " tail -f /tmp/next_slide"' -e 'end tell' };
system($cmd);
while ( $counter <= $#SLIDES ) {
    my $translation = '';

    my $mode = 'text';
    my ( $cols, $rows, undef, undef ) = GetTerminalSize();
    my $slide = $SLIDES[$counter];

    print $next_slide Term::ANSIScreen::cls;
    print $next_slide locate(1,1);
    print $next_slide colored("Time: ".scalar localtime()  ."\n", 'blue');
    print $next_slide colored("Back 1\n", 'red');
    print $next_slide $SLIDES[$counter-1] ."\n\n";
    print $next_slide colored("This slide, $counter/".$#SLIDES."\n", 'blue');
    print $next_slide $SLIDES[$counter] ."\n\n";
    print $next_slide colored("Next slide\n", 'red');
    print $next_slide $SLIDES[$counter+1];
    print $next_slide "\n";	

    my $console = Term::ANSIScreen->new;
    $console->Cls;
    $console->Cursor(1,1);

    # comments
    $slide =~ s/^### .*$//gm;

    if ( $slide =~ s/^#\s*title\s*?(.*?)$//gm ) {
        $title = $1;
    }
	if ($title) {
        my $start = int ( ( $cols / 2 ) - ( length($title) / 2 ) );
	$console->Cursor($start,0);
	chomp $title;
	print "$title\n";
	}

    if ($slide =~ s/#\s*loc-ja\s*(.*?)$//sm) {
	$translation = $1;
    }
    if ($slide =~ s/#\s*`(.*?)`//m) {
	my $cmd = $1;
	if(!$slides_played->{$counter}) {
	`$cmd>/dev/null 2>/dev/null &`;
	$slides_played->{$counter}++}
    }

    if ( $slide =~ s/#\s*mode\s*(\S+)\s*$//gms ) {
        $mode = $1;
    }

    if ( $mode eq 'text' and $slide ) {
        $slide = autoformat $slide, { left => 2, right => ($cols-1), all => 1 };
    }
    else {
	$slide =~ s/^/ /gsm;
	my $tidycols = $cols - 2; # squeeze for display
	open my $out , ">/tmp/output.$$" || die $!;
	print $out $slide || die $!;
	close $out || die $!;
	$slide = ` cat /tmp/output.$$ | source-highlight -s $mode -f esc`;
	#$slide = ` cat /tmp/output.$$ | perltidy -q -l $tidycols| source-highlight -s perl -f esc`;
    }
 
    if ( $slide =~ /(\S+)\s*\n\s*(\S+)/m ) {
	my $lines = ($slide =~ tr/\n//);
	$console->Cursor(0, int(($rows/2)-($lines/2))-1);
    	print $slide;
    } else {
	chomp $slide;
	$slide =~ s/(?:\n|\r)//g;
		my $left = int ( ( $cols / 2 ) - ( length($slide) / 2 ) ); 
	if ($left < 0 ){
		$left = 0;
	}
        $console->Cursor( $left,	int($rows/2)-1, );
	print  colored($slide." \n",'bold blue on white');
    }


    $console->Cursor( 0, ( $rows - 1 ) );
    print colored("$counter/" . $#SLIDES, "bold white");
    if ($translation) {
        my $start = int ( ( $cols / 2 ) - ( length($translation) / 2 ) );
    	$console->Cursor( $start , ( $rows - 1 ) );
    	print colored($translation, "bold yellow on black");
   }
    ReadMode 4;
    my $key = ReadKey(0);
    ReadMode 0;
    if ( $key eq 'q' ) {
        exit;
    }
    if ( $key =~ /^(?: |\n|n)/ ) {
        $counter++;
    } elsif ( $key eq 'e' ) {
	system($ENV{EDITOR}||"vim", $ARGV[0]);
	load_slides();
	next;
    } elsif ( $key eq 'r' ) {
	load_slides();
        next;

    } else {
        $counter--;
        if ( $counter < 0 ) {
            $counter = 0;
        }
    }
}

sub load_slides {
my $file = $ARGV[0] || die "usage: $0 name_of_slides.txt\n";
my $handle;
open( $handle, "<$file" ) || die $!;

my $datadata = join( '', <$handle> );

 @SLIDES  = split( /^----?\s*$/mi, $datadata );
}
