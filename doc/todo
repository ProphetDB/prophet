Todo

    - get a state_db exposed within the RT source
    - extract the reusable bits of Prophet::Sync::Source::RT to
            Prophet::Sync::UpstreamSource
    - implement a simple Prophet::Sync::Source::Hiveminder for "personal tasks only"
    - write tests for RT-prophet-prophet-RT sync
    
    - lunch
    
    - implement uuids for prophet databases
       - (use the uuid as a prefix for the db root?)    
    - design/implement basic non-svn sync protocol

    - sketch out RT scrips replacement

    - dinner



- prophet databases need uuids.
    - each replica should know the uuid of the database it is a replica of
    - merging between replicas with different uuids should require a 'force' argument of some kind.

- refactor Source::integrate_changeset to get the merge ticket and let the source(dst) decide how to record them, rather than having handle does the job
- also need to send along all merge tickets we have


- validation on bug tracker fields
	- severity

- ability to add comments to a bug (visible history entries)
    - maybe long-prop edits

- push to a remote prophet
            
    - bundle all changesets newer than that which we know the other party hasn't seen up as a serialized structure (FeedSync? Storable ;)?)
    - send them to remote to "pull from textfile

- pull from a remote RT by url and query
    - be able to tell RT to only give us history entries newer than the $DATE of RT history entry with ID #1234 (which is the sequence number we used for the merge ticket from the remote RT).

    - massage this crap into a sequence of prophet changesets
    - apply.
    - rt id & record uuid bidirectional mapping how?
        - uuid as a link?
        - get rt to store uuid on all tickets at create time?
            - jesse thinks rt should do this anyway

- issues:
    - how do we validate RT queues?
    - how do we deal with RT rejecting a commit because the committer doesn't have acls?
    - how do we map random remote sd users to rt users?
    

- push to a remote RT
    - get the remote RT to give us its merge tickets ?!
    - for every txn RT hasn't seen, send the txn to remote.
    - if it's a record-create, we need to do some clever mapping.
        "find an RT ticket with the uuid $UUID"
        map that back to local

- Replace this todo list with a svb database
- elegant support for large attachments
- RESTy web server API to let third-parties build non-perl apps against a Prophet Depot

- define a value for a property that is a reference to another record or set of records



Archive:


- when committing any change:
    - record the original depot uuid and change sequence_no as revprops
    - record two merge tickets:
        - sequence_no from the source that gave it to us
        - sequence_no from the original recording source

- naive support for large attachments
- ability to pull non-conflicting updates from a remote db
- implement merge of conflicts with: "local always wins"
- record conflict resolution data 
- reuse conflict resolution data on repeated resolve
- ability to 'pull' conflicting updates from a remote db
- prompt for resolution of conflicts
- handle file_conflict

- test byzantine sync behaviour
- handle conflicting conflict resolutions
- base bug tracking schema

-  ::CLI should automatically discover an app's model class based on the type name @done
- Creation of bug tracking model classes @done
	- status @done
    - relations between models @done
    - find out what the remote _would_ pull by inspecting its merge tickets on  @done
            - current replica @done
        - once we do that, we can find out who _we_ have synced from after that point, right? Then we want: @done
            - anyone we have a merge ticket for _since_ the last time the other party saw us. @done
    - nobu @done
    - get RT to give us a list of ticket records matching our query @done
    - get rt ro give us a list of history entries on those ticket records @done
