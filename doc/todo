
Todo

- refactor Source::integrate_changeset to get the merge ticket and let the source(dst) decide how to record them, rather than having handle does the job
- also need to send along all merge tickets we have


-  ::CLI should automatically discover an app's model class based on the type name @done
- Creation of bug tracking model classes @done
- validation on bug tracker fields
	- status @done
	- severity

- ability to add comments to a bug (visible history entries)
    - relations between models @done
    - maybe long-prop edits

- push to a remote prophet
    - find out what the remote _would_ pull by inspecting its merge tickets on  @done
            - current replica @done
        - once we do that, we can find out who _we_ have synced from after that point, right? Then we want: @done
            - anyone we have a merge ticket for _since_ the last time the other party saw us. @done
            
    - bundle all changesets newer than that which we know the other party hasn't seen up as a serialized structure (FeedSync? Storable ;)?)
    - send them to remote to "pull from textfile
    - nobu @done

- pull from a remote RT by url and query
    - get RT to give us a list of ticket records matching our query @done
    - get rt ro give us a list of history entries on those ticket records @done
    - be able to tell RT to only give us history entries newer than the $DATE of RT history entry with ID #1234 (which is the sequence number we used for the merge ticket from the remote RT).

    - massage this crap into a sequence of prophet changesets
    - apply.
    - rt id & record uuid bidirectional mapping how?
        - uuid as a link?
        - get rt to store uuid on all tickets at create time?
            - jesse thinks rt should do this anyway

- issues:
    - how do we validate RT queues?
    - how do we deal with RT rejecting a commit because the committer doesn't have acls?
    - how do we map random remote sd users to rt users?
    

- push to a remote RT
    - get the remote RT to give us its merge tickets ?!
    - for every txn RT hasn't seen, send the txn to remote.
    - if it's a record-create, we need to do some clever mapping.
        "find an RT ticket with the uuid $UUID"
        map that back to local

- Replace this todo list with a svb database
- elegant support for large attachments
- RESTy web server API to let third-parties build non-perl apps against a Prophet Depot

- define a value for a property that is a reference to another record or set of records



Bug tracker:

     summary  		RT: subject
     status			RT: status(new,open,stalled,resolved, rejected)
     severity		
     custom fields	RT: cf-*
     owner			RT: owner
     keywords/tags	 
[csv]reported by		RT: requestors
     comments		RT: comment/correspond
   					RT: Queue
   					RT: priority
   					RT: initial_priority
   					RT: final_priority
   					RT: time_estimated
   					RT: time_worked
   					RT: time_left
[dt]				RT: created
[dt]    			RT: starts
   					RT: started
   					RT: lastupdated
   					RT: resolved
   					RT: told (last user contact)
[csv] 				RT: links * many
[csv]   				DependsOn
[csv]   				DependedOnBy
[csv]   				RefersTo
[csv]   				ReferredToBy
[csv]					MemberOf
[csv]					HasMember
   					
[csv]  				RT: admin_ccs
[csv]				RT: ccs
   		
   		
				
   		
   					
    attachments / patches
    
    milestones?
    custom fields with possible values - loaded from some other record/table
    
    comments
        seperate records referring to the ticket uuid
        

Done, I think.

- when committing any change:
    - record the original depot uuid and change sequence_no as revprops
    - record two merge tickets:
        - sequence_no from the source that gave it to us
        - sequence_no from the original recording source

- naive support for large attachments
- ability to pull non-conflicting updates from a remote db
- implement merge of conflicts with: "local always wins"
- record conflict resolution data 
- reuse conflict resolution data on repeated resolve
- ability to 'pull' conflicting updates from a remote db
- prompt for resolution of conflicts
- handle file_conflict

- test byzantine sync behaviour
- handle conflicting conflict resolutions
- base bug tracking schema

