#!/usr/bin/perl

use warnings;
use strict;

use Prophet::Sync::Source::SVN;
use Params::Validate;
use Getopt::Long;

my $opts = {};

GetOptions( $opts, 'target=s', 'source=s' );
validate_options($opts);

my $target = Prophet::Sync::Source->new( { url => $opts->{'target'} } );
my $source = Prophet::Sync::Source->new( { url => $opts->{'source'} } );

if ( $target->uuid eq $source->uuid ) {
    fatal_error( "You appear to be trying to merge two identical replicas. "
            . "Either you're trying to merge a replica to itself or "
            . "someone did a bad job cloning your database" );
}

if ( !$target->accepts_changesets ) {
    fatal_error( $target->url . " does not accept changesets. Perhaps it's unwritable or something" );
}

import_changesets( from => $source, to => $target );

exit(0);

sub validate_options {
    my $opts = shift;
    for (qw(source target)) {
        die "You need to specify a --$_ url" unless ( $opts->{$_} );
    }
}

sub fatal_error {
    my $reason = shift;
    die $reason."\n";

}


sub import_changesets {
    my %args   = validate( @_, { from => 1, to => 1 } );
    my $source = $args{'from'};
    my $target = $args{'to'};

    my $changesets_to_integrate
        = $source->fetch_changesets( after => $target->last_changeset_from_source( $source->uuid ) );

    for my $changeset (@$changesets_to_integrate) {
        next if ( $target->has_seen_changeset($changeset) );
        if ( $target->changeset_will_conflict($changeset) ) {

            my $conflicts = $target->conflicts_from_changeset($changeset);

            # write out a nullification changeset beforehand,
            # - that way, the source update will apply cleanly
            # Then write out the source changeset
            # Then write out a new changeset which reverts the parts of the source changeset which target should win
        } else {
            $target->integrate_changeset($changeset);
        }

    }
}


